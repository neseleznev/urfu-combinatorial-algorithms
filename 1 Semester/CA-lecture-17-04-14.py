# -*- coding: UTF-8 -*-
'''
Привет.
____4____. G = (V, E, c) - сеть
p - (v,w) - путь
c(p) = min{ c(e) : e <- p} - вес

Требуется для заданных вершин v, w найти самый надежный путь от v до w (1 - 1).
Т.е. найти (v,w)-путь p такой, что c(p) = max{ c(q) : q - (v,w)-путь }

c(p) =def= maxmin расстояние от v до w

Цепь:
	OOOO ... O 
	O 		O
	 OO ...

 _		|
|_|-----H-- 100
 \      |
  \	    H   200
   \____|

........../\ 
........./**\
......../****\
.......|*****|
.......|*****|
.......|*****|
.......|*****|
.......|*****|
.......|*****|
.......|*****|
.......|*****|
....../***|***\
...../****|****\
..../-----\/--\/----\



───────────────────────────────
──────────▄▄▄▄▄▄▄▄▄▄▄──────────
─────▄▄▀▀▀▀──────────▀▀▄▄──────
───▄▀───────────────────▀▀▄────
──█────────────────────────█───
─█─────────────────────▄▀▀▀▀▀█▄
█▀────────────────────█────▄███
█─────────────────────█────▀███
█─────▄▀▀██▀▄─────────█───────█
█────█──████─█─────────▀▄▄▄▄▄█─
█────█──▀██▀─█───────────────█─
█────█───────█──────────────▄▀─
█────▀▄─────▄▀──▄▄▄▄▄▄▄▄▄───█──
█──────▀▀▀▀▀────█─█─█─█─█──▄▀──
─█──────────────▀▄█▄█▄█▀──▄▀───
──█──────────────────────▄▀────
───▀▀▀▄──────────▄▄▄▄▄▄▀▀──────
────▄▀─────────▀▀──▄▀──────────
──▄▀───────────────█───────────
─▄▀────────────────█──▄▀▀▀█▀▀▄─
─█────█──█▀▀▀▄─────█▀▀────█──█─
▄█────▀▀▀────█─────█────▀▀───█─
█▀▄──────────█─────█▄────────█─
█──▀▀▀▀▀█▄▄▄▄▀─────▀█▀▀▀▄▄▄▄▀──
█───────────────────▀▄─────────




╔═══════════════════╗
║░░░░░░░░░░░░░░░░░░░║
║░╔╦╦═╦╦╦═╦══╦═╦═╗░░║
║░╠╚║╬║║║╠╩╗╔╣║║╠╝░░║
║░║╗╣╔╣║║╠╗║║║║║╠╗░░║
║░╚╩╩╝╚═╩═╝╚╝╚═╩═╝░░║
║░░░░░░░░░░░░░░░░░░░║
║░╔═╦═╦═╦╦╦═╦═╦═╦═╗░║
║░║╚║║║╠╣═╣╬║═╣╠╣═╣░║
║░║╔║║║╠╣║║╔╣═╣╠╣═╣░║
║░╚═╩═╩═╩╩╩╝╚═╩═╩═╝░║
║░░░░░░░░░░░░░░░░░░░║
╚═══════════════════╝

╔════════════════════╗
║░░░░░░░░░░░░░░░░░░░░║
║░╔═╦═╦╦╦═╦══╦╦╦╦╦╦╗░║
║░║╚║║║║║╠╩╗╔╣║║╩║║║░║
║░║╔║║║║║╠╗║║║║║╦╠╗║░║
║░╚═╩═╩═╩═╝╚╝╚═╩╩╩═╝░║
║░░░░░░░░░░░░░░░░░░░░║
║░╔═╦═╦═╦╦╦═╦═╦═╦═╗░░║
║░║╚║║║╠╣═╣╬║═╣╠╣═╣░░║
║░║╔║║║╠╣║║╔╣═╣╠╣═╣░░║
║░╚═╩═╩═╩╩╩╝╚═╩═╩═╝░░║
║░░░░░░░░░░░░░░░░░░░░║
╚════════════════════╝


Spice. Shuttle.
)●)░░░░░░░░░░░░░░░░░░░░░░░░(●(
)●)░░░░░░░░░░░░░░▄░░░░░░░░░(●(
)●)░░░░▄▄▄▄▄▄▄▄▄█▀░░▓▓▓░░░░(●(
)●)░══███░█░█░████░▓▒▒▓▓▓░░(●(
)●)░░░░▀▀▀▀▀▀▀▀▀█▄░░▓▓▓░░░░(●(
)●)░░░░░░░░░░░░░░▀░░░░░░░░░(●(

'''

'''
эээ
дЕйкстра.
d(v) - расст от s до v.
v0 = s; d(v0) = 0
v0, v1, ..., vk
d(v0), d(v1), ..., d(vk)
v[k+1] - ? d(v[k+1]) - ?

t(x) = min{ d(v[i]) + c(v[i], v) }
V* : t(V*) = min{ t(v) : v <- F }
v[k+1] = v*; d[v*] = t(v*)

'''

'''
ALGO:
dm(v) - maxmin расст от s до v.
Вес несущего ребра -inf
V0 = s; dm(V0) = +inf
V0, V1, ..., vk
dm(V0), ..., dm(Vk)

1) dm(V0) >= dm(V1) >= ... >= dm(Vk)
2) для любого v <- F    dm(Vk) >= dm(v)
	F = V \ {V0, ..., Vk}

V[k+1] - ? 			dm(V[k+1]) - ?
для любого v <- F   tm(v) = max{ min{ d(V[i]), c(V[i], v) } }

V* : tm(v*) = max{ tm(v) : v <- F }

Оказывается!
	V[k+1] = V*;   dm(v*) = tm(v*);
Доказательство для детей.


Реализация:
'''





'''
____5____. G = (V, E, c)- сеть
Требуется для всех пар (v, w) выдать кратчайшие (v,w)-пути.

# ||p|| = СИГМА; ||p|| -> min #

Простейшее решение: Из каждой вершины запустить Форда-Беллмана. Ну это ж, это ж, для лохов - O(n^4)

Жи есть для пацанов за O(n^3). Алгоритм Флойда (Уоршолла). 1962г.

(!) Все вершины, ясен пень, занумерованы от 1 до n.
У Форда-Беллмана:
	Dk(v) - длина (s,v)-пути, содержащего не более k ребер.
	Последовательно вычисляются D1(v), D2(v), ..., Dn-1(v).

Dk(i, j) - (i,j)-путь, все номера вершин по пути не более k.
Последовательно D0(i,j), D1(i,j), ..., Dn(i,j)

 /	D0(i,j) = c(i,j)
{
 \	Dk+1(i,j) = min{ Dk(i,j) , Dk(i, k+1) + Dk(k+1, j) }


Реализация:
'''
# Floyd algo.
# Given: G(V,E,c), where
#	c from matrix of costs A[n][n]
#	n = |V|; m = |E|;
#	(There's no negative length cycles in G)
# 
# Result:
# 	D[n][n], pred[n][n], where
#		D[i][j] - Distance from i to j.
#		pred[i][j] - 

import sys

A = [
	[0, 1, 76],
	[-2, 0, -2],
	[3, 7, 0]
]
n = len(A[0])

D = [[0 for j in range(n)] for i in range(n)]
pred = [[0 for j in range(n)] for i in range(n)]

for i in range(n):
	for j in range(n):
		D[i][j] = A[i][j]
		pred[i][j] = i
for k in range(n):
	for i in range(n):
		for j in range(n):
			if D[i][k] + D[k][j] < D[i][j]:
				D[i][j] = D[i][k] + D[k][j]
				pred[i][j] = pred[k][j]

for i in range(n):
	if D[i][i] < 0:
		print('IDINAHUI')
		sys.exit(1)

for d in D:
	print d





'''
1) Min SIGMA - Ford-Bellman, Dijkstra, Bz
2) Max SIGMA - Сетефое планироффание
3) Max PROIZV- Переводка платежа
4) MIN PROIZV- NONE
5) maxmin    - Узкие места
6) minmax    - NONE
7,8) maxmax, minmin - XYNTA => 3. log( c(e) )

'''